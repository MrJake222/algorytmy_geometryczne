\documentclass[12pt]{article}

\usepackage{amssymb} % symbol kąta
\usepackage[polish]{babel} % polskie nazwy
\usepackage[T1]{fontenc} % polskie znaki
\usepackage[margin=1.0in]{geometry} % marginesy
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8} % bloki kodu
\usepackage{color} % kolory
\usepackage{indentfirst} % wcięcie w pierwszej linii paragrafu
\usepackage{graphicx} % obrazy
\usepackage{float} % dla image [H]

% bez odstępu w itemize
\let\tempone\itemize
\let\temptwo\enditemize
\renewenvironment{itemize}{\tempone\setlength{\itemsep}{0cm}}{\temptwo}

\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  
\graphicspath{ {img} }
% obrazek {nazwa.png}{opis}
\newcommand{\imgcustomsize}[3]{
	\begin{figure}[H]
		\centering
		\includegraphics[width=#3\textwidth]{#1}
		\caption{#2}
		\label{#1}
	\end{figure}
}
\newcommand{\img}[2]{\imgcustomsize{#1}{#2}{0.5}}

% dwa obrazki
\newcommand{\imgsidebyside}[4]{
	\begin{figure}[H]
		\centering
		\begin{minipage}{.5\textwidth}
			\centering
			\includegraphics[width=.8\linewidth]{#1}
			\caption{#2}
		\end{minipage}%
		\begin{minipage}{.5\textwidth}
			\centering
			\includegraphics[width=.8\linewidth]{#3}
			\caption{#4}
		\end{minipage}
	\end{figure}
}


% tabela z wynikami {nazwa.txt}{opis}
\newcommand{\tab}[2]{
\begin{table}[H]
	\centering
	\caption{#2}
	\vspace{0.3cm}
	\begin{tabular}{c|c|c|c}
		\lhead{$x_1$}&\thead{$y_1$}&\thead{$x_2$}&\thead{$y_2$}\\
		\hline
		\input{#1}
	\end{tabular}
\end{table}
}

% nagłowek tabeli
\newcommand*{\thead}[1]{\multicolumn{1}{|c}{\bfseries #1}}
\newcommand*{\lhead}[1]{\multicolumn{1}{c}{\bfseries #1}}

\begin{document}
	\lstset{backgroundcolor=\color{lbcolor}, language=Python, inputencoding=utf8}
	
	\title{Graf widzialności \\
		\vspace{0.2cm}
		\large Algorytmy geometryczne \\
		\large Projekt}
	\author{Norbert Morawski\\Dariusz Piwowarski}
	
	\maketitle
	\tableofcontents
	\pagebreak
	
	\section{Informacje techniczne}
	% \hspace{0.5cm}
	\subsection{Platforma}
		\begin{tabular}{l|l}
			System&Arch Linux/Windows 10\\
			Architektura&\texttt{x86\_64}\\
			Język programowania&Python\\
			Wersja interpretera&3.9.7\\
		\end{tabular}

	\subsection{Użyte biblioteki i narzędzia}
		\begin{tabular}{l|l}
			NumPy&1.21.2\\
			MatPlotLib&3.4.3\\
			Jupyer Notebook&6.4.4
		\end{tabular}
	
	\subsection{Opis programu}
		% TODO może coś więcej tutaj
		Program został napisany w języku Python. Interfejs dla użytkownika dostępny jest w pliku \lstinline|.ipynb|, wykorzystuje on narzędzie Jupyter Notebook.
	
	\subsection{Moduły}
		Poniżej znajduje się opis modułów i metod w nich występujących.
	
		\paragraph{\lstinline|create_visibility_graph.py|}
			Zawiera implementację algorytmu obliczania grafu widzialności.
			\begin{itemize}
				\item \lstinline|find_internal_lines| -- Implementuje algorytm znajdywania przekątnych w figurach. Złożoność $ O(n^2) $,
				\item \lstinline|create_visibility_graph| -- Tworzy graf  widzialności.
			\end{itemize}
		
		\paragraph{\lstinline|VisibilityGraph.py|}
			Klasa zawierająca reprezentację finalnego grafu widzialności.
			\begin{itemize}
				\item \lstinline|__init__| -- Konstruktor,
				\item \lstinline|add_edge| -- Dodaje krawędź do grafu,
				\item \lstinline|get_points| -- Zwraca listę krotek reprezentujących zbiór wierzchołków grafu,
				\item \lstinline|get_lines| -- Zwraca listę krawędzi,
				\item \lstinline|get_lines_separately| -- Zwraca listę list krawędzi z podziałem na wierzchołki początkowe krawędzi,
				\item \lstinline|__repr__| -- Zwraca reprezentację tekstową klasy.
			\end{itemize}
		
		\paragraph{\lstinline|Sweeper.py|}
			Klasa zawierająca aktualny stan miotły (punkt początkowy i punkt końcowy)
		
		\paragraph{\lstinline|shortest_path.py|}
			Implementacja algorytmu Dijkstry, który wyznacza najkrótszą ścieżkę pomiędzy przeszkodami.
			\begin{itemize}
				\item \lstinline|dijkstra| -- Implementuje algorytm Dijkstry. Złożoność $ O(n \cdot log(n)) $,
				\item \lstinline|shortest_path| -- Funkcja pomocnicza do wywołania algorytmu Dijkstry.  Dodaje do grafu punkt początkowy i końcowy.
			\end{itemize}
		
		\paragraph{\lstinline|Point.py|}
			Klasa zawierająca reprezentację punktu na płaszczyźnie.
			\begin{itemize}
				\item \lstinline|__init__| -- Konstruktor,
				\item \lstinline|with_line| -- Dodaje krawędź incydentną z tym wierzchołkiem,
				\item \lstinline|has_line_to| -- Sprawdza czy wierzchołek jest incydentny z podaną krawędzią,
				\item \lstinline|has_internal_line_to| -- Sprawdza czy krawędż pomiędzy tym a podanym wierzchołkiem to przekątna, 
				\item \lstinline|__repr__| -- Zwraca reprezentację tekstową klasy.
			\end{itemize}
			
		\paragraph{\lstinline|Line.py|}
			Klasa zawierająca reprezentację odcinka na płaszczyźnie. Wewnętrznie przechowuje jego początek i koniec.
			\begin{itemize}
				\item \lstinline|__init__| -- Konstruktor,
				\item \lstinline|__repr__| -- Zwraca reprezentację tekstową klasy,
				\item \lstinline|__eq__| -- Sprawdza czy linie są sobie równe (porównuje czy mają takie same końce i początki),
				\item \lstinline|__gt__| -- Sprawdza czy linia następuje po podanej linii w strukturze stanu.
			\end{itemize}
					
		\paragraph{\lstinline|Figure.py|}
			Klasa zawierająca reprezentację figury na płaszczyźnie. Wewnętrznie przechowuje listę punktów należących do figury, w kolejności przeciwnej do ruchu wskazówek zegara.
			\begin{itemize}
				\item \lstinline|__init__| -- Konstruktor,
				\item \lstinline|__repr__| -- Zwraca reprezentację tekstową klasy.
			\end{itemize}
		
		\paragraph{\lstinline|plotter/Plotter.py|}
			Klasa obsługująca generowane wykresów krok-po-kroku.
			\begin{itemize}
				\item \lstinline|__init__| -- Konstruktor,
				\item \lstinline|init_limits| -- Pobiera maksymalne i minimalne współrzędne punktów w grafie,
				\item \lstinline|new_partial_plot| -- Tworzy nowy częściowy wykres,
				\item \lstinline|partial_plot| -- Rysuje nowy częściowy wykres,
				\item \lstinline|sum_up| -- Rysuje podsumowanie jednej iteracji zewnętrznej pętli algorytmu.
			\end{itemize}
			
		\paragraph{\lstinline|plotter/SequencePlotter.py|}
			Klasa pomocnicza obsługująca generowanie osobnych wykresów w osobnych plikach, za każdym razem inkrementując numer wykresu.
			\begin{itemize}
				\item \lstinline|__init__| -- Konstruktor,
				\item \lstinline|next| -- Tworzy nowy wykres.
			\end{itemize}

		% TODO opisujemy to?
		\paragraph{\lstinline|plotter/Plot.py|}
			Klasa pomocnicza zawierająca podstawowe funkcje obsługi wykresów.

		% TODO opisujemy to?
		\paragraph{\lstinline|plot_tool.py|}
			Dostarczone narzędzie graficzne.
			
		\paragraph{\lstinline|plot_tool_helpers.py|}
			\begin{itemize}
				% TODO nie wiem
				\item \lstinline|visibility_graph_scenes| -- 
				\item \lstinline|visibility_graph_scenes_separately| -- 
				\item \lstinline|shortest_path_scene| -- 
				\item \lstinline|get_figures_from_plot| -- 
				\item \lstinline|get_points_from_plot| -- 
			\end{itemize}
			
		\paragraph{\lstinline|helpers.py|}
			Zawiera pomocnicze funkcje.
			\begin{itemize}
				\item \lstinline|dist_p_to_intersection| -- oblicza odległość do przecięcia
				\item \lstinline|intersection| -- zwraca przecięcie dwóch linii
				\item \lstinline|orient| -- oblicza wyznacznik i zwraca jak ułożone są punkty 
				\item \lstinline|dist| -- oblicza odległość dwóch punktów
			\end{itemize}
	
	\section{Informacje użytkownika}
	
	\subsection{Uruchomienie programu}
		% TODO może coś więcej tutaj
		Należy w katalogu z plikiem \lstinline|project.ipynb| uruchomić narzędzie Jupyter Notebook.
	
	\subsection{Funkcje programu}
			% TODO Tutaj opis Jupytera
	
	\section{Sprawozdanie}
	
	\subsection{Opis problemu}
		\paragraph{Graf widzialności}
			Jest to graf gdzie zbiorem wierzchołków jest zbiór wierzchołków na płaszczyźnie, a krawędzie istnieją tylko kiedy wierzchołki na płaszczyźnie "widzą się", tzn. nie istnieje pomiędzy nimi przeszkoda w postaci figury.
		
		\paragraph{Wstęp}
			Trywialny algorytm wymagałby sprawdzenia każdej pary wierzchołków w czasie $ O(n^2) $. Każde takie sprawdzenie wymagałoby przejrzenia wszystkich innych wierzchołków w czasie $ O(n) $, co prowadziłoby do algorytmu o złożoności $ O(n^3) $. Jednak jeżeli wykorzystamy zrównoważone drzewo binarne do wyszukiwania przeszkód, jesteśmy w stanie obniżyć złożoność do poziomu $ O(n^2 \cdot log(n)) $.
		
		\paragraph{Algorytm}
			Problem sprowadza się do wyznaczenia widzianych wierzchołków dla każdego z $ n $ punktów. Do tego celu wykorzystamy algorytm zamiatania. Tym razem jednak nie zamiatamy płaszczyzny wzdłuż żadnej z osi, lecz zamiatamy płaszczyznę obracając miotłę.
			
		\paragraph{Zdarzenia i stan miotły}
		Zdarzeniami będą punkty na płaszczyźnie, a struktura stanu będzie przechowywać aktualnie przecinane odcinki w kolejność od najbliższej punktu zaczepienia do najdalszej.
	
	\subsection{Algorytm}
		Zamiatanie płaszczyzny będzie odbywać się wg następujących kroków:
		\begin{itemize}
			\item Zaczep miotłę w badanym punkcie i zwróć ją w kierunku dodatnie półosi OX,
			\item Obracaj miotłą zgodnie ze wskazówkami zegara,
			\item Rozpatruj zdarzenia i aktualizuj strukturę stanu, dodając do grafu widzialności odpowiednie krawędzie.
		\end{itemize}
	
		\subsection{Struktura zdarzeń}
			Struktura zdarzeń została zaimplementowana przy użyciu listy. 
			
			\paragraph{Opis sortowania}
				Zbiór punktów najpierw dzielony jest na dwa podzbiory względem tego czy dany punkt jest na lewo czy na prawo od aktualnie rozpatrywanego punktu (w przypadku gdy leżą one w tym samym miejscu podział następuje po wartości współrzędnej $ x $). Następnie każda część jest sortowana osobno wbudowaną funkcją $ sort $ (sortowanie stabilne) dwukrotnie. W pierwszym sortowaniu kluczem jest odległość od punktu zaczepienia, w drugim stosowany jest wyznacznik aby posortować punkty zgodnie z ruchem wskazówek zegara.
			
			\vspace{\baselineskip} % newline
			Ostatecznie otrzymujemy posortowaną strukturę zdarzeń gdzie punkty występują w kolejności zgodnie z ruchem wskazówek zegara, a punkty współliniowe ułożone są od najbliższych do najdalszych.
			
			\paragraph{Złożoność}
				Struktura zdarzeń nie jest modyfikowana w trakcie działania algorytmu, stąd jej wkład do złożoności jest ograniczony przez sortowanie i wynosi $ O(n \cdot log(n)) $.
		
		\subsection{Struktura stanu}
			Struktura stanu przechowuje krawędzie. Wykorzystuje posortowaną listę (opartą na drzewie binarnym) \lstinline|SortedList| z biblioteki \lstinline|sortedcontainers|. Gwarantuje ona czas operacji rzędu $ O(log(n)) $.
			
			\paragraph{Opis działania}
				Gdy miotła natrafia na punkt, brane są pod uwagę krawędzie incydentne z nim. Jeżeli krawędź została już zamieciona, jest ona usuwana ze struktury. Gdy nie została jeszcze zamieciona, jest dodawana do niej. Test po której stronie znajduje się krawędź jest przeprowadzany przy użyciu wyznacznika.
				
			\paragraph{Porządek elementów}
				Elementy są utrzymywane w porządku rosnącym względem ich odległości od punktu zaczepienia miotły. Jeżeli oba odcinki zaczynają lub kończą się w tym samym punkcie używamy wyznacznika.
				
			\paragraph{Złożoność}
				Na strukturze stanu wykonamy maksymalnie wykonamy $ n $ operacji wstawiania i usuwania, co daje nam czas działania rzędu $ O(n \cdot log(n)) $.
		
		\subsection{Wykrywanie przecięć}
			Gdy zaczynamy rozpatrywać punkt, testujemy czy jest on widziany z punktu zaczepienia miotły.  W algorytmie spotykamy następujące przypadki:
			
			\img{przyp1.jpg}{Przypadek graniczny}
				W tym przypadku najpierw dodany do struktury zostaje punkt $ A $. Następnie rozpatrujemy widoczność punktu $ E $. Algorytm najpierw sprawdza czy punkt poprzednio rozpatrywany należy do tej samej figury. Jeżeli tak, sprawdza czy odcinek $ AE $ przecina wnętrze figury. Jeżeli nie, punkt jest widoczny. Dopuszczamy widoczność wzdłuż krawędzi.
				
			\img{przyp2.jpg}{Przypadek graniczny}
				Gdy punkt $ F $ leży ponad miotłą odcinek $ AE $ przecina wnętrze figury więc punkt $ E $ nie jest widoczny.
			
			\img{przyp3.jpg}{Przypadek graniczny}
				Tutaj punkt $ D $ będzie widoczny. Sprawdzamy czy punkt $ A $ jest widoczny. Jeżeli tak, to wyszukujemy w strukturze stanu czy pomiędzy punktami $ A $ i $ D $ znajduje się jakakolwiek krawędź. Jeżeli nie, rozpatrywany punkt jest widoczny.
				
			\img{przyp4.jpg}{Przypadek graniczny}
				W tym przykładzie punkt $ G $ nie będzie widoczny ponieważ pomiędzy punktem $ A $ (który jest widoczny) a punktem $ G $ w strukturze stanu znajdują się dwie krawędzie.
				
			\img{przyp5.jpg}{Przypadek graniczny}
				W tym przykładzie punkt $ D $ nie ma współliniowych poprzedników w strukturze zdarzeń. W takim przypadku wyszukujemy pierwszy odcinek w strukturze stanu i jeżeli taki istnieje i przecina miotłę to punkt nie będzie widoczny. Szukanie przeszkód przecinających odcinek $ DG $ w tym przypadku nie ma sensu. $ G $ również jest niewidoczny.
			
			\img{przyp6.jpg}{Przypadek graniczny}
				Tutaj odcinek $ AB $ pokrywa się z miotłą. Dopuszczamy widoczność wzdłuż krawędzi. Punkt $ D $ będzie widoczny.
						
		\subsection{Testy}
				Testy odzwierciedlają przedstawione wyżej sytuacje.
			
			\img{test1.png}{Przypadek testowy}
				Wierzchołek widoczny, gdy figura jest wklęsła.
			
			% TODO Nie działa
			%			\img{test2.png}{Przypadek testowy}
			%				Wierzchołek niewidoczny, gdy figura wypukła
			
			\img{test3.png}{Przypadek testowy}
				Wierzchołek widoczny, gdy współliniowe.
			
			\img{test4.png}{Przypadek testowy}
				Wierzchołek niewidoczny, gdy współliniowe, ale zasłania go inna przeszkoda.
			
			\img{test5.png}{Przypadek testowy}
				Wierzchołek niewidoczny, gdy współliniowe, ale pierwszy niewidoczny.
			
			\img{test6.png}{Przypadek testowy}
				Wierzchołek widoczny, gdy miotła pokrywa się z krawędzią.
		
		\subsection{Kroki działania algorytmu}
			Punkt $ A $ jest punktem zaczepienia miotły.
		
			\imgcustomsize{visibility-step000-001.jpg}{Przykład działania}{0.35}
				Algorytm napotyka pierwsze zdarzenie.  Punkt $ D $ jest widoczny, ponieważ struktura stanu jest pusta. Odcinki incydentne $ DB $ i $ DC $ dodawane są do struktury stanu (w tej kolejności).
			
			\imgcustomsize{visibility-step000-002.jpg}{Przykład działania}{0.35}
				$ DB $ jest usuwane ze struktury, $ BC $ zostaje dodane. Punkt $ B $ jest widoczny, ponieważ nie istnieje krawędź przecinająca miotłę pomiędzy $ A $ i $ B $.
			
			\imgcustomsize{visibility-step000-003.jpg}{Przykład działania}{0.35}
				Dodajemy do struktury $ GF $ i $ GE $. Punkt $ G $ nie jest widoczny, bo zasłania go krawędź $ BC $ (pierwsza przecinająca miotłę).
			
			\imgcustomsize{visibility-step000-004.jpg}{Przykład działania}{0.35}
				Usuwamy $ GE $, dodajemy $ EF $. Analogicznie do $ G $, punkt $ E $ nie jest widoczny.
			
			\imgcustomsize{visibility-step000-005.jpg}{Przykład działania}{0.35}
				Usuwamy $ EF $ i $ GF $. Punkt $ F $ niewidoczny.
			
			\imgcustomsize{visibility-step000-006.jpg}{Przykład działania}{0.35}
				Usuwamy $ BC $ i $ DC $. Punkt $ C $ widoczny.
			
			\imgcustomsize{visibility-sum-001.jpg}{Wynik działania}{0.35}
				Tak wygląda wynik wykonania powyższych kroków. Następnie wybierany jest nowy punkt zaczepienia i algorytm powtarza kroki wykonane powyżej.
			
			\imgsidebyside{visibility-sum-002.jpg}{Miotła zaczepiona w $ B $}{visibility-sum-003.jpg}{Miotła zaczepiona w $ C $}
			\imgsidebyside{visibility-sum-004.jpg}{Miotła zaczepiona w $ D $}{visibility-sum-005.jpg}{Miotła zaczepiona w $ E $}
			\imgsidebyside{visibility-sum-006.jpg}{Miotła zaczepiona w $ F $}{visibility-sum-007.jpg}{Miotła zaczepiona w $ G $}
			
			Tak wygląda ostatecznie graf widoczności dla tego przypadku.
			\tab{res/results.txt}{Reprezentacja grafu widzialności poprzez pary punktów}
			

% TODO Testy jakieś\textbf{d}
% TODO bibliografia
\end{document}
